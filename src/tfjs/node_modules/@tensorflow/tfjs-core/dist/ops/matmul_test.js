"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var dl = require("../index");
var test_util_1 = require("../test_util");
var matmul_1 = require("./matmul");
test_util_1.describeWithFlags('matmul', test_util_1.ALL_ENVS, function () {
    it('A x B', function () {
        var a = dl.tensor2d([1, 2, 3, 4, 5, 6], [2, 3]);
        var b = dl.tensor2d([0, 1, -3, 2, 2, 1], [3, 2]);
        var c = dl.matMul(a, b);
        expect(c.shape).toEqual([2, 2]);
        test_util_1.expectArraysClose(c, [0, 8, -3, 20]);
    });
    it('A x B^t', function () {
        var a = dl.tensor2d([1, 2, 3, 4, 5, 6], [2, 3]);
        var b = dl.tensor2d([1, 0, 2, 4, 3, 0], [2, 3]);
        var transposeA = false;
        var transposeB = true;
        var c = dl.matMul(a, b, transposeA, transposeB);
        var expected = [7, 10, 16, 31];
        test_util_1.expectArraysClose(c, expected);
    });
    it('A^t x B', function () {
        var a = dl.tensor2d([1, 2, 3, 4, 5, 6], [2, 3]);
        var b = dl.tensor2d([1, 0, 2, 4, 3, 0], [2, 3]);
        var transposeA = true;
        var transposeB = false;
        var c = dl.matMul(a, b, transposeA, transposeB);
        var expected = [17, 12, 2, 22, 15, 4, 27, 18, 6];
        test_util_1.expectArraysClose(c, expected);
    });
    it('A^t x B^t', function () {
        var a = dl.tensor2d([1, 2, 3, 4, 5, 6], [3, 2]);
        var b = dl.tensor2d([1, 0, 2, 4, 3, 0], [2, 3]);
        var transposeA = true;
        var transposeB = true;
        var c = dl.matMul(a, b, transposeA, transposeB);
        var expected = [11, 13, 14, 20];
        test_util_1.expectArraysClose(c, expected);
    });
    it('A x B^t shapes do not match', function () {
        var a = dl.zeros([2, 3]);
        var b = dl.zeros([3, 2]);
        var f = function () {
            var transposeA = false;
            var transposeB = true;
            dl.matMul(a, b, transposeA, transposeB);
        };
        expect(f).toThrowError();
    });
    it('A^t x B shapes do not match', function () {
        var a = dl.zeros([2, 3]);
        var b = dl.zeros([3, 2]);
        var f = function () {
            var transposeA = true;
            var transposeB = false;
            dl.matMul(a, b, transposeA, transposeB);
        };
        expect(f).toThrowError();
    });
    it('A^t x B^t shapes do not match', function () {
        var a = dl.zeros([3, 2]);
        var b = dl.zeros([3, 2]);
        var f = function () {
            var transposeA = true;
            var transposeB = true;
            dl.matMul(a, b, transposeA, transposeB);
        };
        expect(f).toThrowError();
    });
    it('matmul throws when inner dimensions dont match', function () {
        var a = dl.tensor2d([1, 2, 3, 4, 5, 6], [2, 3]);
        var b = dl.tensor2d([0, 1, -3, 2, 2, 1, 2, 2], [4, 2]);
        expect(function () { return dl.matMul(a, b); }).toThrowError();
    });
    it('matmul throws when passed non matrices', function () {
        var a = dl.tensor3d([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], [2, 3, 2]);
        var b = dl.tensor2d([0, 1, -3, 2, 2, 1, 2, 2], [4, 2]);
        expect(function () { return dl.matMul(a, b); }).toThrowError();
        expect(function () { return dl.matMul(b, a); }).toThrowError();
    });
    it('Vector times matrix', function () {
        var v = dl.tensor1d([2, 3]);
        var matrix = dl.tensor2d([1, 2, 3, 4], [2, 2]);
        var result = dl.vectorTimesMatrix(v, matrix);
        var expected = [11, 16];
        test_util_1.expectArraysClose(result, expected);
    });
    it('Vector times matrix with implicit reshape', function () {
        var v = dl.tensor1d([2, 3]);
        var matrix = dl.tensor2d([1, 2, 3, 4], [2, 2]);
        var result = dl.vectorTimesMatrix(v, matrix);
        var expected = [11, 16];
        test_util_1.expectArraysClose(result, expected);
    });
    it('Vector times matrix throws when not passed a vector', function () {
        var v = dl.tensor2d([1, 2, 3, 4], [2, 2]);
        var matrix = dl.tensor2d([1, 2, 3, 4], [2, 2]);
        expect(function () { return dl.vectorTimesMatrix(v, matrix); }).toThrowError();
    });
    it('Vector times matrix throws when not passed a matrix', function () {
        var v = dl.tensor1d([2, 3]);
        var matrix = dl.tensor3d([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 2]);
        expect(function () { return dl.vectorTimesMatrix(v, matrix); }).toThrowError();
    });
    it('Matrix times vector', function () {
        var matrix = dl.tensor2d([1, 2, 3, 4], [2, 2]);
        var v = dl.tensor1d([2, 3]);
        var result = dl.matrixTimesVector(matrix, v);
        var expected = [8, 18];
        test_util_1.expectArraysClose(result, expected);
    });
    it('Matrix * vector propagates NaNs', function () {
        var matrix = dl.tensor2d([1, 2, 3, 4], [2, 2]);
        var v = dl.tensor1d([2, NaN]);
        var result = dl.matrixTimesVector(matrix, v);
        var expected = [NaN, NaN];
        test_util_1.expectArraysClose(result, expected);
    });
    it('matrix times vector throws when not passed a vector', function () {
        var v = dl.tensor2d([1, 2, 3, 4], [2, 2]);
        var matrix = dl.tensor2d([1, 2, 3, 4], [2, 2]);
        expect(function () { return dl.matrixTimesVector(matrix, v); }).toThrowError();
    });
    it('matrix times vector throws when not passed a matrix', function () {
        var v = dl.tensor1d([2, 3]);
        var matrix = dl.tensor3d([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 2]);
        expect(function () { return dl.matrixTimesVector(matrix, v); }).toThrowError();
    });
    it('Dot product', function () {
        var v1 = dl.tensor1d([2, 3]);
        var v2 = dl.tensor1d([2, 1]);
        var result = matmul_1.MatmulOps.dotProduct(v1, v2);
        test_util_1.expectNumbersClose(result.get(), 7);
    });
    it('Dot product propagates NaNs', function () {
        var v1 = dl.tensor1d([2, NaN]);
        var v2 = dl.tensor1d([2, 1]);
        var result = matmul_1.MatmulOps.dotProduct(v1, v2);
        expect(result.get()).toEqual(NaN);
    });
    it('Dot product throws when vectors are different size', function () {
        var v1 = dl.tensor1d([2, 3, 3]);
        var v2 = dl.tensor1d([2, 1]);
        expect(function () { return matmul_1.MatmulOps.dotProduct(v1, v2); }).toThrowError();
        expect(function () { return matmul_1.MatmulOps.dotProduct(v2, v1); }).toThrowError();
    });
    it('Dot product throws when passed non vectors', function () {
        var v1 = dl.tensor2d([1, 2, 3, 3], [2, 2]);
        var v2 = dl.tensor1d([2, 1]);
        expect(function () { return matmul_1.MatmulOps.dotProduct(v1, v2); }).toThrowError();
        expect(function () { return matmul_1.MatmulOps.dotProduct(v2, v1); }).toThrowError();
    });
    it('Outer product', function () {
        var v1 = dl.tensor1d([2, 3]);
        var v2 = dl.tensor1d([2, 1]);
        var result = dl.outerProduct(v1, v2);
        var expected = [4, 2, 6, 3];
        expect(result.shape).toEqual([2, 2]);
        test_util_1.expectArraysClose(result, expected);
    });
    it('gradients: A * B', function () {
        var a = dl.tensor2d([1, 2, 3, 10, 20, 30], [2, 3]);
        var b = dl.tensor2d([2, 3, 4, 1, 2, 3], [3, 2]);
        var dy = dl.tensor2d([1, 10, 20, 30], [2, 2]);
        var transposeA = false;
        var transposeB = false;
        var grads = dl.grads(function (a, b) {
            return dl.matMul(a, b, transposeA, transposeB);
        });
        var _a = grads([a, b], dy), da = _a[0], db = _a[1];
        expect(da.shape).toEqual(a.shape);
        test_util_1.expectArraysClose(da, [
            dy.get(0, 0) * b.get(0, 0) + dy.get(0, 1) * b.get(0, 1),
            dy.get(0, 0) * b.get(1, 0) + dy.get(0, 1) * b.get(1, 1),
            dy.get(0, 0) * b.get(2, 0) + dy.get(0, 1) * b.get(2, 1),
            dy.get(1, 0) * b.get(0, 0) + dy.get(1, 1) * b.get(0, 1),
            dy.get(1, 0) * b.get(1, 0) + dy.get(1, 1) * b.get(1, 1),
            dy.get(1, 0) * b.get(2, 0) + dy.get(1, 1) * b.get(2, 1)
        ], 1e-1);
        expect(db.shape).toEqual(b.shape);
        test_util_1.expectArraysClose(db, [
            a.get(0, 0) * dy.get(0, 0) + a.get(1, 0) * dy.get(1, 0),
            a.get(0, 0) * dy.get(0, 1) + a.get(1, 0) * dy.get(1, 1),
            a.get(0, 1) * dy.get(0, 0) + a.get(1, 1) * dy.get(1, 0),
            a.get(0, 1) * dy.get(0, 1) + a.get(1, 1) * dy.get(1, 1),
            a.get(0, 2) * dy.get(0, 0) + a.get(1, 2) * dy.get(1, 0),
            a.get(0, 2) * dy.get(0, 1) + a.get(1, 2) * dy.get(1, 1)
        ]);
    });
});
test_util_1.describeWithFlags('matmul webgl-only', test_util_1.WEBGL_ENVS, function () {
    it('Matrix times vector, large matrix', function () {
        var maxTexSize = 16000;
        var sharedDim = maxTexSize + 4;
        var matrix = dl.buffer([2, sharedDim], 'float32');
        matrix.set(1, 0, sharedDim - 3);
        matrix.set(1, 0, sharedDim - 2);
        var v = dl.buffer([sharedDim], 'float32');
        v.set(1, sharedDim - 3);
        v.set(1, sharedDim - 2);
        var result = dl.matrixTimesVector(matrix.toTensor(), v.toTensor());
        var expected = [2, 0];
        test_util_1.expectArraysClose(result, expected);
    });
});
