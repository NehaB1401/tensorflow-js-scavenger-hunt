"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var dl = require("../index");
var test_util_1 = require("../test_util");
test_util_1.describeWithFlags('multinomial', test_util_1.ALL_ENVS, function () {
    var NUM_SAMPLES = 10000;
    var EPSILON = 0.05;
    it('Flip a fair coin and check bounds', function () {
        var probs = dl.tensor1d([0.5, 0.5]);
        var seed = null;
        var normalized = true;
        var result = dl.multinomial(probs, NUM_SAMPLES, seed, normalized);
        expect(result.dtype).toBe('int32');
        expect(result.shape).toEqual([NUM_SAMPLES]);
        var outcomeProbs = computeProbs(result.dataSync(), 2);
        test_util_1.expectArraysClose(outcomeProbs, [0.5, 0.5], EPSILON);
    });
    it('Flip a two-sided coin with 100% of heads', function () {
        var probs = dl.tensor1d([1, 0]);
        var seed = null;
        var normalized = true;
        var result = dl.multinomial(probs, NUM_SAMPLES, seed, normalized);
        expect(result.dtype).toBe('int32');
        expect(result.shape).toEqual([NUM_SAMPLES]);
        var outcomeProbs = computeProbs(result.dataSync(), 2);
        test_util_1.expectArraysClose(outcomeProbs, [1, 0], EPSILON);
    });
    it('Flip a two-sided coin with 100% of tails', function () {
        var probs = dl.tensor1d([0, 1]);
        var seed = null;
        var normalized = true;
        var result = dl.multinomial(probs, NUM_SAMPLES, seed, normalized);
        expect(result.dtype).toBe('int32');
        expect(result.shape).toEqual([NUM_SAMPLES]);
        var outcomeProbs = computeProbs(result.dataSync(), 2);
        test_util_1.expectArraysClose(outcomeProbs, [0, 1], EPSILON);
    });
    it('Flip a single-sided coin throws error', function () {
        var probs = dl.tensor1d([1]);
        var seed = null;
        var normalized = true;
        expect(function () { return dl.multinomial(probs, NUM_SAMPLES, seed, normalized); })
            .toThrowError();
    });
    it('Flip a ten-sided coin and check bounds', function () {
        var numOutcomes = 10;
        var probs = dl.buffer([numOutcomes], 'float32');
        for (var i = 0; i < numOutcomes; ++i) {
            probs.set(1 / numOutcomes, i);
        }
        var seed = null;
        var normalized = true;
        var result = dl.multinomial(probs.toTensor(), NUM_SAMPLES, seed, normalized);
        expect(result.dtype).toBe('int32');
        expect(result.shape).toEqual([NUM_SAMPLES]);
        var outcomeProbs = computeProbs(result.dataSync(), numOutcomes);
        expect(outcomeProbs.length).toBeLessThanOrEqual(numOutcomes);
    });
    it('Flip 3 three-sided coins, each coin is 100% biases', function () {
        var numOutcomes = 3;
        var probs = dl.tensor2d([[0, 0, 1], [0, 1, 0], [1, 0, 0]], [3, numOutcomes]);
        var seed = null;
        var normalized = true;
        var result = dl.multinomial(probs, NUM_SAMPLES, seed, normalized);
        expect(result.dtype).toBe('int32');
        expect(result.shape).toEqual([3, NUM_SAMPLES]);
        var outcomeProbs = computeProbs(result.dataSync().slice(0, NUM_SAMPLES), numOutcomes);
        test_util_1.expectArraysClose(outcomeProbs, [0, 0, 1], EPSILON);
        outcomeProbs = computeProbs(result.dataSync().slice(NUM_SAMPLES, 2 * NUM_SAMPLES), numOutcomes);
        test_util_1.expectArraysClose(outcomeProbs, [0, 1, 0], EPSILON);
        outcomeProbs =
            computeProbs(result.dataSync().slice(2 * NUM_SAMPLES), numOutcomes);
        test_util_1.expectArraysClose(outcomeProbs, [1, 0, 0], EPSILON);
    });
    it('passing Tensor3D throws error', function () {
        var probs = dl.zeros([3, 2, 2]);
        var seed = null;
        var normalized = true;
        expect(function () { return dl.multinomial(probs, 3, seed, normalized); })
            .toThrowError();
    });
    function computeProbs(events, numOutcomes) {
        var counts = [];
        for (var i = 0; i < numOutcomes; ++i) {
            counts[i] = 0;
        }
        var numSamples = events.length;
        for (var i = 0; i < events.length; ++i) {
            counts[events[i]]++;
        }
        for (var i = 0; i < counts.length; i++) {
            counts[i] /= numSamples;
        }
        return counts;
    }
});
